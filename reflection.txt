
SECTION 1.	DESCRIPTION
INTRODUCTION & BACKGROUND
	During my first rotation   in 2023 I focused on the project: Engineering Insights, which is a repository   that will be used to analyse engineering data.  Currently, we use a variety of tools to collect these insights, including:
•	GitHub for tracking current vulnerabilities of open-source software or finding out who is in what group, what permission users have in this groups
•	the Jenkins pipeline for collecting a variety of metrics, including test coverage, SpotBugs , Checkstyle ,or  PMD  warning results.

However, this can be time-consuming and inefficient. Our new repository will group all this information in one place, making it easier for us to find the required data. 

Furthermore, another advantage of having that data centralised is a summary of information about all the repositories in an organization. This will help to evaluate if developers of LGIM follow best practices. For example, it is possible to quickly find out: 
•	How many repositories have protection rules enabled?
•	For repositories that have protection rules enabled, how many branches have required approval?
•	How many repositories have protection rules enabled?
•	For repositories that have protection rules enabled, how many branches have required approval?
•	If there are any repositories where anybody can check in to any code.
Overall, the Engineering-Insights metrics could be a valuable tool for our organization because they can be used to improve the quality of the code that LGIM developers produce.
AIMS & OBJECTIVES	
My task was to develop a feature, which will help to find  non-standard groups (outside collaborators)  for a specific repository. To achieve this, I will need to:
1.	Learn the Quarkus framework.
2.	Understand the flow of the existing code in the repository to be able to integrate my code to the current one
3.	Learn to write GraphQL queries.
4.	Understand what GitHub non-standard groups are.
5.	Refresh my knowledge of database operations and JPA specification.
6.	Practice git commands in a real-life scenario project (personal objective).
7.	Write high-level documentation about the project (motivation).

I have 3 months to complete this project, with the help of a personal mentor and coach, Andrew Buttery. I also have access to the necessary resources, such as YouTube, Pluralsight courses, and documentation for the used tools. I believe these objectives are achievable, and the final product will follow the company’s best standard code quality, which is a lack of Checkstyle Spotbugs warnings, and also a high level of code coverage.
STAKEHOLDERS	
TIMETABLE, BUDGET & CONSTRAINTS	

SECTION 2.	APPROACH
Methodology	In this project, I followed a methodology that focused on collaboration, continuous improvement, and quick feedback. Although we did not have a specific name for our methodology, we implemented several Agile practices to help us manage the project effectively. When I say we I mean myself and my coach: Andrew Buttery.
We held daily stand-ups to keep me motivated and to answer my questions.    This helped us stay focused and make progress towards our goals.

As the only person working on the project at the time, I collaborated with my coach during our regular meetings on MS Meets. He gave me tasks to work on and helped me debug any code issues I encountered. Sometimes we engaged in pair programming, which helped improve code quality and coding standards.
To facilitate collaboration and version control, I created my own branch on GitHub where I could commit and push my changes to the remote repository. This allowed for continuous improvement and quick feedback, two important Agile values.

I used Java, Quarkus framework, and JPA data for data access in my code, and I integrated my code with existing code when developing new features. When I realized I pushed code that caused a test to fail, I quickly come up with a fix, which was in line with the Agile value of working software.
I considered my coach to be the customer in this project, which made it easier to collaborate during stand-ups. I also worked on code that was previously developed by other apprentices, which made it a collective effort.

Finally, I planned my specific tasks by prioritizing them and ensuring that I did not overwork myself. I worked for 35 hours per week and avoided working on weekends to promote developer welfare and avoid a burnout.
Overall, our methodology for this project was focused on Agile values and practices that prioritized collaboration, continuous improvement, and quick feedback.
Tools	In my project, I utilized a variety of hardware and software tools to aid in the development process. I chose these tools based on their functionality and compatibility with the project's needs. Some of the software tools I utilized include Java version 19, Maven for managing and downloading dependencies, Quarkus framework, JPA specification, and Hibernate as the implementation to store and retrieve data from the database. I also used a PostgreSQL database to store data and the Git version control system to communicate with the remote repository, commit and push changes, create branches, and cancel changes from my working directory and cancel changes from my local repository.

To monitor the database, I used an internal IntelliJ database tool where I could observe the schema when I created a relation between tables and see data that the code created and utilized. In addition, I used the Persistence tool --also internal tool of Enterprise IntelliJ-- which allowed me to see a diagram of all entities and their relationships. For the data delivery system, I utilized a Kafka customer which delivered a JSON file.

During the development process, I also utilized Jenkins for continuous integration and SonarQube to perform static code analysis to ensure high code quality. I chose these tools because of their ability to streamline the development process and identify and fix any issues early on.
In terms of research and training I engage in continuous learning and development, utilizing online resources such as Stack Overflow and reading articles on industry best practices. I used online course on Plural Sight I also received guidance and support from my coach, who helped me to develop my skills and knowledge throughout the project








SECTION 3.	COMPETENCY BASED EVIDENCE
Skills, Knowledge, Behaviours you are reflecting on	When I joined the development process of the project, there were already some features developed by previous apprentices, who spent their rotation time working on the project earlier on, also the main person responsible for the project -the maintainer, was actively contributing to the codebase.  

On the first day I was introduced to the Insight Engineering repository. I found out that the project utilises the Quarkus framework (java). I was unfamiliar with the Quarkus framework at the time but after some glimpses at the codebase, I just assumed it was a specific flavour of Spring Boot. I was given a couple of days to get familiar with the already-written repository. 

After checking out the code again and again, I started to understand the flow of the code, I noticed that I did not understand many annotations like: “@Observes” or “@ApplicationScoped”. Therefore, I did online research to realise I was wrong with my framework assumption that Spring Boot and Quarkus is the same one.  

I recalled the words of my coach that the project was written in Quarkus, which is a completely different framework than Spring Boot. I read the documentation and quickly I found out that even though it was a new framework for me, the overall concept and architecture were like Spring Boot. This was because both frameworks use the same specification: JPA s well as the same implementation: Hibernate as it goes about data persistence.

Quarkus documentation is focused on its capabilities and guides: on how to do certain things. However, it does not explain the meaning of annotations, I mentioned about earlier on. It does though mention on the first page it uses Context Dependency Injection for managing beans. CDI was a keyword where to search for the knowledge I wanted to learn. Once I found out that Quarkus was based on a Java EE specification called CDI - it was easy to get information about these new annotations. Knowing the basic of the framework, it seemed to be very intuitive to work with.

The current workflow of the repo—I work on -- is quite simple. One of the entry points is inside Kafka consumer. Every time a build process in Jenkins’s pipeline starts (for example when a new code is committed to the any Github repo of the organization) Kafka Consumer is activated, and its function process starts its work. That function receives   from Kafka-queue a JSON file, which converts received information about the build (project name, repository address on Github) into SoftwareService object.

Kafka Consumer depends on GithubService object, which adds extra information (Vulnerabilities) to our SoftwareService. Under the hood GithubService performs GraphQL queries on the Github endpoint to retrieve data.
Later, I will integrate my part inside GithubService class inside the function populateCollaborators where I could retrieve collection of outside Collaborators and then I will update SoftwareService with this new collection.  That function also saves that collection to PostgreSQL database. 

Once I got familiar with the code I was presented with my main task. Additionally, I also was guided step by step, to help me achieve the main objective.  So, my next subtask involved utilising the Github API endpoint with GraphQL to fetch outside collaborators from a particular repository. This required me to familiarise myself with the completely new technology for me:  GraphQL .

It is like REST API to get data from the endpoint, the difference is that client can ask for data that is exactly what is needed, whereas with REST API we experience quite often over-fetching, and quite often to get the required results we need to make more than one call, therefore it takes longer. I found that the most challenging aspect of GraphQL was understanding the concept of edges and nodes. It took me some time to grasp the relationship between these two, Thanks to graphic documentation and my coach I got a deeper understanding and in short edges are the connections between the nodes, therefore edges contain nodes and some extra information: most of the time needed for pagination.

At one point I got confused with all these groups like outside collaborators, contributors, and team members inside the organization, which Github has introduced. To resolve this, I turned to GitHub documentation for guidance to find out that the organisation was created by my company to ease collaboration between its members. Within the organisation, there are some built-in roles like the owner (who is like an admin with most permissions to manage the organization) and member (default role of the users of the organization with basic permissions like creating repositories). Members can be assigned to a specific team (group of members) to ease permission management. Outside collaborator :it is a role for a person who does not belong to the organization but has some granted permissions only to a specific repository, therefore its permissions are limited and for example, the outside collaborator will not be able to create a new repository inside the organisation. If an outside collaborator or a team member contributes to the repository, such as submitting a pull request that is accepted, such a user will be listed as a contributor to the repository.

Clarifying these terms helped me fully understand what non-standard groups meant. These are meant to be a group of users or a user whose assigned role of permission to the repo as an outside collaborator. Armed with all that knowledge I started to practice making GraphQL queries to get these users. My coach suggested using the application: INSOMNIA, which could help make such GraphQL queries. Because of security reasons, I cannot just download the application from the internet, so I had to follow company procedures and order that application through company tech path. Unfortunately, it was not available for deployment, and I was asked to order for packaging and deployment. Because it was time-consuming, I did not want to wait for deployment for 4 working days I started to make queries using JavaScript. Spending a significant amount of time practising GraphQL queries I came up with my solution, which consulted with Andrew I eventually had the final query.

To integrate my code with the current code base I followed overall practises and created a new branch: "collaborator" using git hence making sure that the changes I am going to make will not affect the main codebase, additionally helping me to keep track of my changes.

Quarkus framework supports a query language   with the help of the SmallRye GraphQL Client dependency. So, to take the advantage of this feature I just needed to create the interface with annotation “@GraphQLClientApi”, where I defined   the operations needed to be performed on GitHub endpoint (i.e.to send GraphQL request and parse the response into java objects), which is a function declaration. Obviously, the program can run correctly   only when a concrete implementation of this interface exists. This is exactly what Quarkus does during compile time of java project. It generates the implementation   of the interface and reuses the model classes, which I create next.

The difficult part was to code those model classes because they must adhere to GitHub schema, which defines the structure of the data that is available   through the GitHub API. During creation of model classes I simplified the process of defining getters and setters, as well as method for creating the object itself (Builder Design Pattern ) by using Lombok tool.

To finish my main task I had to 






There is also another branch created by me (readme), where I provide a high-level overview of the Engineering Insight Repository.

Evidence	

SECTION 4.	CONCLUSION
skills, knowledge, behaviours you are reflecting on	Reflecting on my experience as an apprentice software developer working on the Quarkus repository, I am proud of the work I accomplished and the knowledge I gained throughout the project. Using GraphQL to make GitHub queries and get collaborators for specific repos was a challenging yet rewarding task, and learning how to save that data in a PostgreSQL database was a valuable skill to add to my arsenal. 

One of the key takeaways from this project was the importance of efficient and effective collaboration. As part of a larger team, it was essential that we communicated effectively and worked together to achieve our goals. Through this process, I was able to hone my communication skills and learn how to work collaboratively in a fast-paced environment.

Another valuable lesson I learned was the importance of adaptability and flexibility in software development. As we worked on the project, we encountered unexpected challenges and obstacles that required us to pivot and adjust our approach. By embracing this flexibility, we were able to overcome these challenges and ultimately deliver a successful project.

Working on the Quarkus repository also provided me with the opportunity to deepen my knowledge of GraphQL and PostgreSQL. These technologies have become increasingly important in the world of software development, and I feel confident that the experience I gained during this project will serve me well in future endeavors.

Overall, my experience as an apprentice software developer working on the Quarkus repository was both challenging and rewarding. Through this project, I gained valuable skills and knowledge that will serve me well in my future career as a software developer. I am grateful for the opportunity to work on such an exciting project and look forward to continuing to learn and grow as a software developer.






could complain here about the architecture of GithubService class, because it has a lot of responsibilities here. It retrieves data from Github, it also saves this data to central PostgreSQL database and on top of that it updates SoftwareService object. I dd not want to introduce anything new to already established codebase. So, I just follow the pattern of previous engineer and how he did handled vulnerabilities.

•	Why I think collaborator is so importsant
•	Also why quarlkus was chosen over spring boot
•	Some code improvements like switch, dedicated exception instead of the general one.


SECTION 5.	APPENDICES
skills, knowledge, behaviours you are reflecting on	


